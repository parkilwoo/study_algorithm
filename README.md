## Algorithm

1. 누적합(Prefix-sum), 부분합(Partial-sum) 알고리즘

* 누적합:

    배열의 "처음부터 특정 위치까지"의 합을 미리 계산하는것
    
    연속된 배열의 합이 특정 값에 근사하는 시점을 찾을 때 유용함(leetcode 560)

* 부분합:

    배열의 "연속된 부분 구간"의 합을 계산(leetcode 53)

    보통 누적합을 구하고 그 값으로 부분합을 구하는 경우가 많음.

    n부터 k까지의 부분합은 '누적합[k] - 누적합[n-1]'
    
* 최대 부분합을 찾는 방법:

    1. 누적합 배열을 만든 후
    2. 누적합 배열을 왼쪽 부터 순회하면서
    3. 현재 위치의 최대 부분합 후보 = 현재 누적합 - 최소 누적합
    4. 최소 누적합을 갱신
    
    
    * 최대 부분합 후보를 먼저 구하는 이유 -> 현재 위치는 최소 누적합에 포함이 되면 안되기 때문임 (현재 누적합 - 최소 누적합)
    * 최소 누적합을 0으로 초기화 하는 이유 -> 시작 전 위치를 '가상의 누적합0'으로 넣어두어, 0번째 시작하는 구간도 계산에 포함 가능
    
     
2. 슬라이딩 윈도우(Sliding window)

* 슬라이딩 윈도우:

    두개의 포인터(일반적으로 left, right)를 이용해서 배열이나 문자열의 특정 범위를 효율적으로 탐색하는 알고리즘.
  
    마치 '창문'처럼 윈도우 크기를 늘리거나 줄이면서 문제를 해결한다.

* 슬라이딩 윈도우 원리:

    1. 윈도우 확장: right 포인터를 오른쪽으로 이동시켜 윈도우를 확장한다. 이 때, 새로운 요소가 윈도우에 들어온다.
    2. 계산/판단: 윈도우내의 요소들을 이용해서 문제해결에 필요한 계산이나 조건을 만족하는지 확인한다.
    3. 윈도우 축소: 만약 윈도우가 조건을 만족하지 못하면 left 포인터를 오른쪽으로 이동시켜 윈도우의 크기를 줄인다. 이 과정에서 윈도우의 시작점이 변경된다(요소 삭제)
    4. 일반적인 window size -> right-left+1

 * 관련 문제:

    1. Longest Substring Without Repeating Characters
    2. Minimum Size Subarray Sum
    3. Longest Repeating Character Replacement
    4. Permutation in String

  
